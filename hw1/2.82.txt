2.82:
For all x and y, x, y are a random integers and ux, uy are the corresponding integers cast to unsigned

A)  (x<y) ==(-x>-y)
    This is not always hold a value of one. Consider the arguments where x = INT_MIN and y = INT_MIN + 1.
    This creates the bitpattern x = 0x80000000 and y = 80000001. Negating x we get x = 0x80000000, and in negating 
    y we get y = 0x7FFFFFFF. The bit pattern for x = INT_MIN and for y = INT_MAX. so -x is not greater than -y, but 
    x is less than y
B)  ((x+y) << 4) + y - x == 17 * y + 15 * x
    This will always return one. This is because the two operations on either side are funcitonally equivalent. 
    Multiplying by 16 is the same as a right shift by 4. So then the addition of y and the subtraction of x results
    in the right hand side of the equation. They will behave the same and are likely going to be compiled into similar 
    instructions for efficency sake. 

    
C)  ~x + ~y + 1 == ~(x + y)
    This will always work because the signed numbers are represented using two's complement. Negating a value in two's 
    complement is equivalent to taking the negation operator and adding one. so the left hand side would be equivalent to 
    -x-y-2+1 and the right hand side is equivalent to -(x+y)-1. So the results will always be equal. in the case of overflow, if 
    the least significant 32 bits are taken, then we will overflow in the same manner on each side and remain equivalent.
    
D)  (ux -uy) == - (unsigned)(y-x)
    this is not a valid expression. There cannot be a negation applied to an unsigned integer in c. However, the expression 
    can be compiled if the "-" as put in the book is replaced with "~". In this case the equation will not always hold. Consider 
    x = y = 1. The left hand side will be eaual to 0. But the right hand side will be equal to ~(unsigned)(0) == UINT_MAX.

E)  ((x>>2) << 2)<=x
    This does not always hold. Consider X = INT_MIN. working through the expression we can note (x>>2) == x, x<<2 is
    correspondingly less negative (0's will be shifted in). So the final value will be greater than the initial input.

F)  x % 8 == (x & 7)
    This will not be true for when x is negative. for example if x is -1 x&7 is 1 but x&8 is -1. So the expressions are not 
    always equal.
G)  ((unsigned) -1 / 255 * (x & 255)) >> 24 == (x & 255)
    This will always be true. This is because the value generated by the expression ((unsigned) -1 / 255) is 0x00808081.
    This will multiply our value by 2^8x for 0<=x<=4. x&255 truncates the integer to the bottom 8 bits. This results in the 
    integer appearing in the top 8 bits of the product. Shifting this by 24 bits will recover the bottom 8 bits of x.
    So the two expressions are always equal.